import { unzip } from "unzipit";
import { assert, fetch_range, strip_prefix } from "./util.js";
/**
 * Type guard to verify a ZipEntry has the internal properties we rely on.
 * This protects against changes in unzipit internals.
 */
function isZipEntryInternal(entry) {
    if (!("compressionMethod" in entry) || !("_rawEntry" in entry)) {
        return false;
    }
    const rawEntry = entry._rawEntry;
    return (typeof entry.compressionMethod === "number" &&
        typeof rawEntry === "object" &&
        rawEntry !== null &&
        "relativeOffsetOfLocalHeader" in rawEntry &&
        typeof rawEntry.relativeOffsetOfLocalHeader === "number");
}
export class BlobReader {
    blob;
    constructor(blob) {
        this.blob = blob;
    }
    async getLength() {
        return this.blob.size;
    }
    async read(offset, length) {
        const blob = this.blob.slice(offset, offset + length);
        return new Uint8Array(await blob.arrayBuffer());
    }
}
export class HTTPRangeReader {
    url;
    length;
    #overrides;
    constructor(url, opts = {}) {
        this.url = url;
        this.#overrides = opts.overrides ?? {};
    }
    async getLength() {
        if (this.length === undefined) {
            const req = await fetch(this.url, {
                ...this.#overrides,
                method: "HEAD",
            });
            assert(req.ok, `failed http request ${this.url}, status: ${req.status}: ${req.statusText}`);
            this.length = Number(req.headers.get("content-length"));
            if (Number.isNaN(this.length)) {
                throw Error("could not get length");
            }
        }
        return this.length;
    }
    async read(offset, size) {
        if (size === 0) {
            return new Uint8Array(0);
        }
        const req = await fetch_range(this.url, offset, size, this.#overrides);
        assert(req.ok, `failed http request ${this.url}, status: ${req.status} offset: ${offset} size: ${size}: ${req.statusText}`);
        return new Uint8Array(await req.arrayBuffer());
    }
}
/** @experimental */
class ZipFileStore {
    info;
    reader;
    constructor(reader, opts = {}) {
        this.reader = reader;
        this.info = unzip(reader).then((info) => {
            if (opts.transformEntries) {
                info.entries = opts.transformEntries(info.entries);
            }
            return info;
        });
    }
    /**
     * Compute the byte offset where entry data begins in the zip file.
     * This requires reading the local file header to get filename and extra field lengths.
     */
    async getEntryDataOffset(entry) {
        const localHeaderOffset = entry._rawEntry.relativeOffsetOfLocalHeader;
        // Read local file header (30 bytes minimum)
        const header = await this.reader.read(localHeaderOffset, 30);
        // File name length at offset 26 (2 bytes, little-endian)
        const fileNameLength = header[26] + header[27] * 256;
        // Extra field length at offset 28 (2 bytes, little-endian)
        const extraFieldLength = header[28] + header[29] * 256;
        // Data starts after: local header (30) + filename + extra field
        return localHeaderOffset + 30 + fileNameLength + extraFieldLength;
    }
    async get(key) {
        let entry = (await this.info).entries[strip_prefix(key)];
        if (!entry)
            return;
        return new Uint8Array(await entry.arrayBuffer());
    }
    async getRange(key, range) {
        const entry = (await this.info).entries[strip_prefix(key)];
        if (!entry)
            return undefined;
        if (!isZipEntryInternal(entry)) {
            throw new Error("ZipFileStore.getRange requires internal unzipit properties that are not available. " +
                "This may indicate an incompatible version of unzipit.");
        }
        // For compressed entries, fall back to reading full entry and slicing
        if (entry.compressionMethod !== 0) {
            const bytes = await this.get(key);
            if (!bytes)
                return undefined;
            if ("suffixLength" in range) {
                return bytes.slice(-range.suffixLength);
            }
            return bytes.slice(range.offset, range.offset + range.length);
        }
        // For uncompressed (stored) entries, read directly from underlying reader
        const dataOffset = await this.getEntryDataOffset(entry);
        if ("suffixLength" in range) {
            const start = dataOffset + entry.size - range.suffixLength;
            return this.reader.read(start, range.suffixLength);
        }
        return this.reader.read(dataOffset + range.offset, range.length);
    }
    async has(key) {
        return strip_prefix(key) in (await this.info).entries;
    }
    static fromUrl(href, opts = {}) {
        return new ZipFileStore(new HTTPRangeReader(href, opts), opts);
    }
    static fromBlob(blob, opts = {}) {
        return new ZipFileStore(new BlobReader(blob), opts);
    }
}
export default ZipFileStore;
//# sourceMappingURL=zip.js.map