{
  "version": 3,
  "sources": ["../../geotiff/dist-module/predictor.js", "../../geotiff/dist-module/compression/basedecoder.js"],
  "sourcesContent": ["function decodeRowAcc(row, stride) {\r\n    let length = row.length - stride;\r\n    let offset = 0;\r\n    do {\r\n        for (let i = stride; i > 0; i--) {\r\n            row[offset + stride] += row[offset];\r\n            offset++;\r\n        }\r\n        length -= stride;\r\n    } while (length > 0);\r\n}\r\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\r\n    let index = 0;\r\n    let count = row.length;\r\n    const wc = count / bytesPerSample;\r\n    while (count > stride) {\r\n        for (let i = stride; i > 0; --i) {\r\n            row[index + stride] += row[index];\r\n            ++index;\r\n        }\r\n        count -= stride;\r\n    }\r\n    const copy = row.slice();\r\n    for (let i = 0; i < wc; ++i) {\r\n        for (let b = 0; b < bytesPerSample; ++b) {\r\n            row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\r\n        }\r\n    }\r\n}\r\nexport function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {\r\n    if (!predictor || predictor === 1) {\r\n        return block;\r\n    }\r\n    for (let i = 0; i < bitsPerSample.length; ++i) {\r\n        if (bitsPerSample[i] % 8 !== 0) {\r\n            throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\r\n        }\r\n        if (bitsPerSample[i] !== bitsPerSample[0]) {\r\n            throw new Error('When decoding with predictor, all samples must have the same size.');\r\n        }\r\n    }\r\n    const bytesPerSample = bitsPerSample[0] / 8;\r\n    const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\r\n    for (let i = 0; i < height; ++i) {\r\n        // Last strip will be truncated if height % stripHeight != 0\r\n        if (i * stride * width * bytesPerSample >= block.byteLength) {\r\n            break;\r\n        }\r\n        let row;\r\n        if (predictor === 2) { // horizontal prediction\r\n            switch (bitsPerSample[0]) {\r\n                case 8:\r\n                    row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\r\n                    break;\r\n                case 16:\r\n                    row = new Uint16Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);\r\n                    break;\r\n                case 32:\r\n                    row = new Uint32Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);\r\n                    break;\r\n                default:\r\n                    throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\r\n            }\r\n            decodeRowAcc(row, stride);\r\n        }\r\n        else if (predictor === 3) { // horizontal floating point\r\n            row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\r\n            decodeRowFloatingPoint(row, stride, bytesPerSample);\r\n        }\r\n    }\r\n    return block;\r\n}\r\n", "import { applyPredictor } from '../predictor.js';\r\nexport default class BaseDecoder {\r\n    constructor(parameters) {\r\n        this.parameters = parameters;\r\n    }\r\n    /**\r\n     * @abstract\r\n     */\r\n    decodeBlock(_buffer) {\r\n        throw new Error('decodeBlock not implemented');\r\n    }\r\n    async decode(buffer) {\r\n        const decoded = await this.decodeBlock(buffer);\r\n        const { tileWidth, tileHeight, predictor, bitsPerSample, planarConfiguration, } = this.parameters;\r\n        if (predictor !== 1) {\r\n            return applyPredictor(decoded, predictor, tileWidth, tileHeight, bitsPerSample, planarConfiguration);\r\n        }\r\n        return decoded;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
