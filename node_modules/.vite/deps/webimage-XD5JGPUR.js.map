{
  "version": 3,
  "sources": ["../../geotiff/dist-module/compression/webimage.js"],
  "sourcesContent": ["import BaseDecoder from './basedecoder.js';\n/**\n * class WebImageDecoder\n *\n * This decoder uses the browsers image decoding facilities to read image\n * formats like WebP when supported.\n */\nexport default class WebImageDecoder extends BaseDecoder {\n    constructor(parameters) {\n        super(parameters);\n        if (typeof createImageBitmap === 'undefined') {\n            throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\n        }\n        else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\n            throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\n        }\n    }\n    async decodeBlock(buffer) {\n        const blob = new Blob([buffer]);\n        const imageBitmap = await createImageBitmap(blob);\n        let canvas;\n        if (typeof document !== 'undefined') {\n            canvas = document.createElement('canvas');\n            canvas.width = imageBitmap.width;\n            canvas.height = imageBitmap.height;\n        }\n        else {\n            canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n        }\n        // Draw the image onto the canvas to extract the pixel data.\n        // Note: createImageBitmap always returns RGBA data.\n        const ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n        ctx.drawImage(imageBitmap, 0, 0);\n        const imageData = ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data;\n        // Return the correct channels to the caller\n        const samplesPerPixel = this.parameters.samplesPerPixel || 4;\n        if (samplesPerPixel === 4) {\n            // RGBA, return as is\n            return imageData.buffer;\n        }\n        else if (samplesPerPixel === 3) {\n            // RGB, remove alpha channel before returning\n            const rgb = new Uint8ClampedArray(imageBitmap.width * imageBitmap.height * 3);\n            for (let i = 0, j = 0; i < rgb.length; i += 3, j += 4) {\n                rgb[i] = imageData[j];\n                rgb[i + 1] = imageData[j + 1];\n                rgb[i + 2] = imageData[j + 2];\n            }\n            return rgb.buffer;\n        }\n        else {\n            throw new Error(`Unsupported SamplesPerPixel value: ${samplesPerPixel}`);\n        }\n    }\n}\n"],
  "mappings": ";;;;;;AAOA,IAAqB,kBAArB,cAA6C,YAAY;AAAA,EACrD,YAAY,YAAY;AACpB,UAAM,UAAU;AAChB,QAAI,OAAO,sBAAsB,aAAa;AAC1C,YAAM,IAAI,MAAM,gEAAgE;AAAA,IACpF,WACS,OAAO,aAAa,eAAe,OAAO,oBAAoB,aAAa;AAChF,YAAM,IAAI,MAAM,qFAAqF;AAAA,IACzG;AAAA,EACJ;AAAA,EACA,MAAM,YAAY,QAAQ;AACtB,UAAM,OAAO,IAAI,KAAK,CAAC,MAAM,CAAC;AAC9B,UAAM,cAAc,MAAM,kBAAkB,IAAI;AAChD,QAAI;AACJ,QAAI,OAAO,aAAa,aAAa;AACjC,eAAS,SAAS,cAAc,QAAQ;AACxC,aAAO,QAAQ,YAAY;AAC3B,aAAO,SAAS,YAAY;AAAA,IAChC,OACK;AACD,eAAS,IAAI,gBAAgB,YAAY,OAAO,YAAY,MAAM;AAAA,IACtE;AAGA,UAAM;AAAA;AAAA,MAA+C,OAAO,WAAW,IAAI;AAAA;AAC3E,QAAI,UAAU,aAAa,GAAG,CAAC;AAC/B,UAAM,YAAY,IAAI,aAAa,GAAG,GAAG,YAAY,OAAO,YAAY,MAAM,EAAE;AAEhF,UAAM,kBAAkB,KAAK,WAAW,mBAAmB;AAC3D,QAAI,oBAAoB,GAAG;AAEvB,aAAO,UAAU;AAAA,IACrB,WACS,oBAAoB,GAAG;AAE5B,YAAM,MAAM,IAAI,kBAAkB,YAAY,QAAQ,YAAY,SAAS,CAAC;AAC5E,eAAS,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,GAAG,KAAK,GAAG;AACnD,YAAI,CAAC,IAAI,UAAU,CAAC;AACpB,YAAI,IAAI,CAAC,IAAI,UAAU,IAAI,CAAC;AAC5B,YAAI,IAAI,CAAC,IAAI,UAAU,IAAI,CAAC;AAAA,MAChC;AACA,aAAO,IAAI;AAAA,IACf,OACK;AACD,YAAM,IAAI,MAAM,sCAAsC,eAAe,EAAE;AAAA,IAC3E;AAAA,EACJ;AACJ;",
  "names": []
}
