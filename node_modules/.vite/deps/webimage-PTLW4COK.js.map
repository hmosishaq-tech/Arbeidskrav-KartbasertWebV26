{
  "version": 3,
  "sources": ["../../geotiff/dist-module/compression/webimage.js"],
  "sourcesContent": ["import BaseDecoder from './basedecoder.js';\r\n/**\r\n * class WebImageDecoder\r\n *\r\n * This decoder uses the browsers image decoding facilities to read image\r\n * formats like WebP when supported.\r\n */\r\nexport default class WebImageDecoder extends BaseDecoder {\r\n    constructor(parameters) {\r\n        super(parameters);\r\n        if (typeof createImageBitmap === 'undefined') {\r\n            throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\r\n        }\r\n        else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\r\n            throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\r\n        }\r\n    }\r\n    async decodeBlock(buffer) {\r\n        const blob = new Blob([buffer]);\r\n        const imageBitmap = await createImageBitmap(blob);\r\n        let canvas;\r\n        if (typeof document !== 'undefined') {\r\n            canvas = document.createElement('canvas');\r\n            canvas.width = imageBitmap.width;\r\n            canvas.height = imageBitmap.height;\r\n        }\r\n        else {\r\n            canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\r\n        }\r\n        // Draw the image onto the canvas to extract the pixel data.\r\n        // Note: createImageBitmap always returns RGBA data.\r\n        const ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\r\n        ctx.drawImage(imageBitmap, 0, 0);\r\n        const imageData = ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data;\r\n        // Return the correct channels to the caller\r\n        const samplesPerPixel = this.parameters.samplesPerPixel || 4;\r\n        if (samplesPerPixel === 4) {\r\n            // RGBA, return as is\r\n            return imageData.buffer;\r\n        }\r\n        else if (samplesPerPixel === 3) {\r\n            // RGB, remove alpha channel before returning\r\n            const rgb = new Uint8ClampedArray(imageBitmap.width * imageBitmap.height * 3);\r\n            for (let i = 0, j = 0; i < rgb.length; i += 3, j += 4) {\r\n                rgb[i] = imageData[j];\r\n                rgb[i + 1] = imageData[j + 1];\r\n                rgb[i + 2] = imageData[j + 2];\r\n            }\r\n            return rgb.buffer;\r\n        }\r\n        else {\r\n            throw new Error(`Unsupported SamplesPerPixel value: ${samplesPerPixel}`);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;AAOA,IAAqB,kBAArB,cAA6C,YAAY;AAAA,EACrD,YAAY,YAAY;AACpB,UAAM,UAAU;AAChB,QAAI,OAAO,sBAAsB,aAAa;AAC1C,YAAM,IAAI,MAAM,gEAAgE;AAAA,IACpF,WACS,OAAO,aAAa,eAAe,OAAO,oBAAoB,aAAa;AAChF,YAAM,IAAI,MAAM,qFAAqF;AAAA,IACzG;AAAA,EACJ;AAAA,EACA,MAAM,YAAY,QAAQ;AACtB,UAAM,OAAO,IAAI,KAAK,CAAC,MAAM,CAAC;AAC9B,UAAM,cAAc,MAAM,kBAAkB,IAAI;AAChD,QAAI;AACJ,QAAI,OAAO,aAAa,aAAa;AACjC,eAAS,SAAS,cAAc,QAAQ;AACxC,aAAO,QAAQ,YAAY;AAC3B,aAAO,SAAS,YAAY;AAAA,IAChC,OACK;AACD,eAAS,IAAI,gBAAgB,YAAY,OAAO,YAAY,MAAM;AAAA,IACtE;AAGA,UAAM;AAAA;AAAA,MAA+C,OAAO,WAAW,IAAI;AAAA;AAC3E,QAAI,UAAU,aAAa,GAAG,CAAC;AAC/B,UAAM,YAAY,IAAI,aAAa,GAAG,GAAG,YAAY,OAAO,YAAY,MAAM,EAAE;AAEhF,UAAM,kBAAkB,KAAK,WAAW,mBAAmB;AAC3D,QAAI,oBAAoB,GAAG;AAEvB,aAAO,UAAU;AAAA,IACrB,WACS,oBAAoB,GAAG;AAE5B,YAAM,MAAM,IAAI,kBAAkB,YAAY,QAAQ,YAAY,SAAS,CAAC;AAC5E,eAAS,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,GAAG,KAAK,GAAG;AACnD,YAAI,CAAC,IAAI,UAAU,CAAC;AACpB,YAAI,IAAI,CAAC,IAAI,UAAU,IAAI,CAAC;AAC5B,YAAI,IAAI,CAAC,IAAI,UAAU,IAAI,CAAC;AAAA,MAChC;AACA,aAAO,IAAI;AAAA,IACf,OACK;AACD,YAAM,IAAI,MAAM,sCAAsC,eAAe,EAAE;AAAA,IAC3E;AAAA,EACJ;AACJ;",
  "names": []
}
