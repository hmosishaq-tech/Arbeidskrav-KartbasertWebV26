{
  "version": 3,
  "sources": ["../../geotiff/dist-module/compression/jpeg.js"],
  "sourcesContent": ["import BaseDecoder from './basedecoder.js';\r\n/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\r\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\r\n/*\r\n   Copyright 2011 notmasteryet\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n*/\r\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\r\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\r\n// - The JFIF specification can be found in the JPEG File Interchange Format\r\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\r\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\r\n//   in PostScript Level 2, Technical Note #5116\r\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\r\nconst dctZigZag = new Int32Array([\r\n    0,\r\n    1, 8,\r\n    16, 9, 2,\r\n    3, 10, 17, 24,\r\n    32, 25, 18, 11, 4,\r\n    5, 12, 19, 26, 33, 40,\r\n    48, 41, 34, 27, 20, 13, 6,\r\n    7, 14, 21, 28, 35, 42, 49, 56,\r\n    57, 50, 43, 36, 29, 22, 15,\r\n    23, 30, 37, 44, 51, 58,\r\n    59, 52, 45, 38, 31,\r\n    39, 46, 53, 60,\r\n    61, 54, 47,\r\n    55, 62,\r\n    63,\r\n]);\r\nconst dctCos1 = 4017; // cos(pi/16)\r\nconst dctSin1 = 799; // sin(pi/16)\r\nconst dctCos3 = 3406; // cos(3*pi/16)\r\nconst dctSin3 = 2276; // sin(3*pi/16)\r\nconst dctCos6 = 1567; // cos(6*pi/16)\r\nconst dctSin6 = 3784; // sin(6*pi/16)\r\nconst dctSqrt2 = 5793; // sqrt(2)\r\nconst dctSqrt1d2 = 2896; // sqrt(2) / 2\r\n/** @typedef {(number|HuffmanNode)[]} HuffmanNode */\r\n/** @typedef {{children: HuffmanNode, index: number}} Code */\r\n/**\r\n * @param {Uint8Array<ArrayBuffer>} codeLengths\r\n * @param {Uint8Array<ArrayBuffer>} values\r\n * @returns {HuffmanNode}\r\n */\r\nfunction buildHuffmanTable(codeLengths, values) {\r\n    let k = 0;\r\n    /** @type {Array<Code>} */\r\n    const code = [];\r\n    let length = 16;\r\n    while (length > 0 && !codeLengths[length - 1]) {\r\n        --length;\r\n    }\r\n    code.push({ children: [], index: 0 });\r\n    /** @type {Code|undefined} */\r\n    let p = code[0];\r\n    /** @type {Code|undefined} */\r\n    let q;\r\n    for (let i = 0; i < length; i++) {\r\n        for (let j = 0; j < codeLengths[i]; j++) {\r\n            p = code.pop();\r\n            if (!p) {\r\n                throw new Error('buildHuffmanTable: codeLength mismatch');\r\n            }\r\n            p.children[p.index] = values[k];\r\n            while (p.index > 0) {\r\n                p = code.pop();\r\n                if (!p) {\r\n                    throw new Error('buildHuffmanTable: codeLength mismatch');\r\n                }\r\n            }\r\n            p.index++;\r\n            code.push(p);\r\n            while (code.length <= i) {\r\n                code.push(q = { children: [], index: 0 });\r\n                p.children[p.index] = q.children;\r\n                p = q;\r\n            }\r\n            k++;\r\n        }\r\n        if (i + 1 < length) {\r\n            // p here points to last code\r\n            code.push(q = { children: [], index: 0 });\r\n            p.children[p.index] = q.children;\r\n            p = q;\r\n        }\r\n    }\r\n    return code[0].children;\r\n}\r\nfunction decodeScan(data, initialOffset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {\r\n    const { mcusPerLine, progressive } = frame;\r\n    const startOffset = initialOffset;\r\n    let offset = initialOffset;\r\n    let bitsData = 0;\r\n    let bitsCount = 0;\r\n    function readBit() {\r\n        if (bitsCount > 0) {\r\n            bitsCount--;\r\n            return (bitsData >> bitsCount) & 1;\r\n        }\r\n        bitsData = data[offset++];\r\n        if (bitsData === 0xFF) {\r\n            const nextByte = data[offset++];\r\n            if (nextByte) {\r\n                throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);\r\n            }\r\n            // unstuff 0\r\n        }\r\n        bitsCount = 7;\r\n        return bitsData >>> 7;\r\n    }\r\n    function decodeHuffman(tree) {\r\n        let node = tree;\r\n        let bit;\r\n        while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign\r\n            node = node[bit];\r\n            if (typeof node === 'number') {\r\n                return node;\r\n            }\r\n            if (typeof node !== 'object') {\r\n                throw new Error('invalid huffman sequence');\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function receive(initialLength) {\r\n        let length = initialLength;\r\n        let n = 0;\r\n        while (length > 0) {\r\n            const bit = readBit();\r\n            if (bit === null) {\r\n                return undefined;\r\n            }\r\n            n = (n << 1) | bit;\r\n            --length;\r\n        }\r\n        return n;\r\n    }\r\n    function receiveAndExtend(length) {\r\n        const n = receive(length);\r\n        if (n === undefined) {\r\n            return undefined;\r\n        }\r\n        if (n >= 1 << (length - 1)) {\r\n            return n;\r\n        }\r\n        return n + (-1 << length) + 1;\r\n    }\r\n    function decodeBaseline(component, zz) {\r\n        const t = decodeHuffman(component.huffmanTableDC);\r\n        const diff = t === 0 ? 0 : receiveAndExtend(t);\r\n        component.pred += diff;\r\n        zz[0] = component.pred;\r\n        let k = 1;\r\n        while (k < 64) {\r\n            const rs = decodeHuffman(component.huffmanTableAC);\r\n            if (rs === null) {\r\n                throw new Error('Unexpected end of data in AC coefficient decoding');\r\n            }\r\n            const s = rs & 15;\r\n            const r = rs >> 4;\r\n            if (s === 0) {\r\n                if (r < 15) {\r\n                    break;\r\n                }\r\n                k += 16;\r\n            }\r\n            else {\r\n                k += r;\r\n                const z = dctZigZag[k];\r\n                zz[z] = receiveAndExtend(s);\r\n                k++;\r\n            }\r\n        }\r\n    }\r\n    function decodeDCFirst(component, zz) {\r\n        const t = decodeHuffman(component.huffmanTableDC);\r\n        const value = receiveAndExtend(t);\r\n        if (value === undefined) {\r\n            throw new Error('Unexpected end of data in DC coefficient decoding');\r\n        }\r\n        const diff = t === 0 ? 0 : (value << successive);\r\n        component.pred += diff;\r\n        zz[0] = component.pred;\r\n    }\r\n    function decodeDCSuccessive(component, zz) {\r\n        zz[0] |= readBit() << successive;\r\n    }\r\n    let eobrun = 0;\r\n    function decodeACFirst(component, zz) {\r\n        if (eobrun > 0) {\r\n            eobrun--;\r\n            return;\r\n        }\r\n        let k = spectralStart;\r\n        const e = spectralEnd;\r\n        while (k <= e) {\r\n            const rs = decodeHuffman(component.huffmanTableAC);\r\n            if (rs === null) {\r\n                throw new Error('Unexpected end of data in AC coefficient decoding');\r\n            }\r\n            const s = rs & 15;\r\n            const r = rs >> 4;\r\n            if (s === 0) {\r\n                if (r < 15) {\r\n                    const value = receive(r);\r\n                    if (value === undefined) {\r\n                        throw new Error('Unexpected end of data in AC coefficient decoding');\r\n                    }\r\n                    eobrun = value + (1 << r) - 1;\r\n                    break;\r\n                }\r\n                k += 16;\r\n            }\r\n            else {\r\n                k += r;\r\n                const z = dctZigZag[k];\r\n                const value = receiveAndExtend(s);\r\n                if (value === undefined) {\r\n                    throw new Error('Unexpected end of data in AC coefficient decoding');\r\n                }\r\n                zz[z] = value * (1 << successive);\r\n                k++;\r\n            }\r\n        }\r\n    }\r\n    let successiveACState = 0;\r\n    let successiveACNextValue;\r\n    function decodeACSuccessive(component, zz) {\r\n        let k = spectralStart;\r\n        const e = spectralEnd;\r\n        let r = 0;\r\n        while (k <= e) {\r\n            const z = dctZigZag[k];\r\n            const direction = zz[z] < 0 ? -1 : 1;\r\n            switch (successiveACState) {\r\n                case 0: { // initial state\r\n                    const rs = decodeHuffman(component.huffmanTableAC);\r\n                    if (rs === null) {\r\n                        throw new Error('Unexpected end of data in AC coefficient decoding');\r\n                    }\r\n                    const s = rs & 15;\r\n                    r = rs >> 4;\r\n                    if (s === 0) {\r\n                        if (r < 15) {\r\n                            const value = receive(r);\r\n                            if (value === undefined) {\r\n                                throw new Error('Unexpected end of data in AC coefficient decoding');\r\n                            }\r\n                            eobrun = value + (1 << r);\r\n                            successiveACState = 4;\r\n                        }\r\n                        else {\r\n                            r = 16;\r\n                            successiveACState = 1;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (s !== 1) {\r\n                            throw new Error('invalid ACn encoding');\r\n                        }\r\n                        successiveACNextValue = receiveAndExtend(s);\r\n                        successiveACState = r ? 2 : 3;\r\n                    }\r\n                    continue; // eslint-disable-line no-continue\r\n                }\r\n                case 1: // skipping r zero items\r\n                case 2:\r\n                    if (zz[z]) {\r\n                        zz[z] += (readBit() << successive) * direction;\r\n                    }\r\n                    else {\r\n                        r--;\r\n                        if (r === 0) {\r\n                            successiveACState = successiveACState === 2 ? 3 : 0;\r\n                        }\r\n                    }\r\n                    break;\r\n                case 3: // set value for a zero item\r\n                    if (zz[z]) {\r\n                        zz[z] += (readBit() << successive) * direction;\r\n                    }\r\n                    else {\r\n                        zz[z] = successiveACNextValue << successive;\r\n                        successiveACState = 0;\r\n                    }\r\n                    break;\r\n                case 4: // eob\r\n                    if (zz[z]) {\r\n                        zz[z] += (readBit() << successive) * direction;\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            k++;\r\n        }\r\n        if (successiveACState === 4) {\r\n            eobrun--;\r\n            if (eobrun === 0) {\r\n                successiveACState = 0;\r\n            }\r\n        }\r\n    }\r\n    function decodeMcu(component, decodeFunction, mcu, row, col) {\r\n        const mcuRow = (mcu / mcusPerLine) | 0;\r\n        const mcuCol = mcu % mcusPerLine;\r\n        const blockRow = (mcuRow * component.v) + row;\r\n        const blockCol = (mcuCol * component.h) + col;\r\n        decodeFunction(component, component.blocks[blockRow][blockCol]);\r\n    }\r\n    function decodeBlock(component, decodeFunction, mcu) {\r\n        const blockRow = (mcu / component.blocksPerLine) | 0;\r\n        const blockCol = mcu % component.blocksPerLine;\r\n        decodeFunction(component, component.blocks[blockRow][blockCol]);\r\n    }\r\n    const componentsLength = components.length;\r\n    let component;\r\n    let i;\r\n    let j;\r\n    let k;\r\n    let n;\r\n    let decodeFn;\r\n    if (progressive) {\r\n        if (spectralStart === 0) {\r\n            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\r\n        }\r\n        else {\r\n            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\r\n        }\r\n    }\r\n    else {\r\n        decodeFn = decodeBaseline;\r\n    }\r\n    let mcu = 0;\r\n    let marker;\r\n    let mcuExpected;\r\n    if (componentsLength === 1) {\r\n        mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\r\n    }\r\n    else {\r\n        mcuExpected = mcusPerLine * frame.mcusPerColumn;\r\n    }\r\n    const usedResetInterval = resetInterval || mcuExpected;\r\n    while (mcu < mcuExpected) {\r\n        // reset interval stuff\r\n        for (i = 0; i < componentsLength; i++) {\r\n            components[i].pred = 0;\r\n        }\r\n        eobrun = 0;\r\n        if (componentsLength === 1) {\r\n            component = components[0];\r\n            for (n = 0; n < usedResetInterval; n++) {\r\n                decodeBlock(component, decodeFn, mcu);\r\n                mcu++;\r\n            }\r\n        }\r\n        else {\r\n            for (n = 0; n < usedResetInterval; n++) {\r\n                for (i = 0; i < componentsLength; i++) {\r\n                    component = components[i];\r\n                    const { h, v } = component;\r\n                    for (j = 0; j < v; j++) {\r\n                        for (k = 0; k < h; k++) {\r\n                            decodeMcu(component, decodeFn, mcu, j, k);\r\n                        }\r\n                    }\r\n                }\r\n                mcu++;\r\n                // If we've reached our expected MCU's, stop decoding\r\n                if (mcu === mcuExpected) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // find marker\r\n        bitsCount = 0;\r\n        marker = (data[offset] << 8) | data[offset + 1];\r\n        if (marker < 0xFF00) {\r\n            throw new Error('marker was not found');\r\n        }\r\n        if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\r\n            offset += 2;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return offset - startOffset;\r\n}\r\nfunction buildComponentData(frame, component) {\r\n    const lines = [];\r\n    const { blocksPerLine, blocksPerColumn } = component;\r\n    const samplesPerLine = blocksPerLine << 3;\r\n    const R = new Int32Array(64);\r\n    const r = new Uint8Array(64);\r\n    // A port of poppler's IDCT method which in turn is taken from:\r\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\r\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\r\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\r\n    //   988-991.\r\n    function quantizeAndInverse(zz, dataOut, dataIn) {\r\n        const qt = component.quantizationTable;\r\n        let v0;\r\n        let v1;\r\n        let v2;\r\n        let v3;\r\n        let v4;\r\n        let v5;\r\n        let v6;\r\n        let v7;\r\n        let t;\r\n        const p = dataIn;\r\n        let i;\r\n        // dequant\r\n        for (i = 0; i < 64; i++) {\r\n            p[i] = zz[i] * qt[i];\r\n        }\r\n        // inverse DCT on rows\r\n        for (i = 0; i < 8; ++i) {\r\n            const row = 8 * i;\r\n            // check for all-zero AC coefficients\r\n            if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0\r\n                && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0\r\n                && p[7 + row] === 0) {\r\n                t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;\r\n                p[0 + row] = t;\r\n                p[1 + row] = t;\r\n                p[2 + row] = t;\r\n                p[3 + row] = t;\r\n                p[4 + row] = t;\r\n                p[5 + row] = t;\r\n                p[6 + row] = t;\r\n                p[7 + row] = t;\r\n                continue; // eslint-disable-line no-continue\r\n            }\r\n            // stage 4\r\n            v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;\r\n            v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;\r\n            v2 = p[2 + row];\r\n            v3 = p[6 + row];\r\n            v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;\r\n            v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;\r\n            v5 = p[3 + row] << 4;\r\n            v6 = p[5 + row] << 4;\r\n            // stage 3\r\n            t = (v0 - v1 + 1) >> 1;\r\n            v0 = (v0 + v1 + 1) >> 1;\r\n            v1 = t;\r\n            t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;\r\n            v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;\r\n            v3 = t;\r\n            t = (v4 - v6 + 1) >> 1;\r\n            v4 = (v4 + v6 + 1) >> 1;\r\n            v6 = t;\r\n            t = (v7 + v5 + 1) >> 1;\r\n            v5 = (v7 - v5 + 1) >> 1;\r\n            v7 = t;\r\n            // stage 2\r\n            t = (v0 - v3 + 1) >> 1;\r\n            v0 = (v0 + v3 + 1) >> 1;\r\n            v3 = t;\r\n            t = (v1 - v2 + 1) >> 1;\r\n            v1 = (v1 + v2 + 1) >> 1;\r\n            v2 = t;\r\n            t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\r\n            v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\r\n            v7 = t;\r\n            t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\r\n            v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\r\n            v6 = t;\r\n            // stage 1\r\n            p[0 + row] = v0 + v7;\r\n            p[7 + row] = v0 - v7;\r\n            p[1 + row] = v1 + v6;\r\n            p[6 + row] = v1 - v6;\r\n            p[2 + row] = v2 + v5;\r\n            p[5 + row] = v2 - v5;\r\n            p[3 + row] = v3 + v4;\r\n            p[4 + row] = v3 - v4;\r\n        }\r\n        // inverse DCT on columns\r\n        for (i = 0; i < 8; ++i) {\r\n            const col = i;\r\n            // check for all-zero AC coefficients\r\n            if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0\r\n                && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0\r\n                && p[(7 * 8) + col] === 0) {\r\n                t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;\r\n                p[(0 * 8) + col] = t;\r\n                p[(1 * 8) + col] = t;\r\n                p[(2 * 8) + col] = t;\r\n                p[(3 * 8) + col] = t;\r\n                p[(4 * 8) + col] = t;\r\n                p[(5 * 8) + col] = t;\r\n                p[(6 * 8) + col] = t;\r\n                p[(7 * 8) + col] = t;\r\n                continue; // eslint-disable-line no-continue\r\n            }\r\n            // stage 4\r\n            v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;\r\n            v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;\r\n            v2 = p[(2 * 8) + col];\r\n            v3 = p[(6 * 8) + col];\r\n            v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;\r\n            v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;\r\n            v5 = p[(3 * 8) + col];\r\n            v6 = p[(5 * 8) + col];\r\n            // stage 3\r\n            t = (v0 - v1 + 1) >> 1;\r\n            v0 = (v0 + v1 + 1) >> 1;\r\n            v1 = t;\r\n            t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;\r\n            v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;\r\n            v3 = t;\r\n            t = (v4 - v6 + 1) >> 1;\r\n            v4 = (v4 + v6 + 1) >> 1;\r\n            v6 = t;\r\n            t = (v7 + v5 + 1) >> 1;\r\n            v5 = (v7 - v5 + 1) >> 1;\r\n            v7 = t;\r\n            // stage 2\r\n            t = (v0 - v3 + 1) >> 1;\r\n            v0 = (v0 + v3 + 1) >> 1;\r\n            v3 = t;\r\n            t = (v1 - v2 + 1) >> 1;\r\n            v1 = (v1 + v2 + 1) >> 1;\r\n            v2 = t;\r\n            t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\r\n            v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\r\n            v7 = t;\r\n            t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\r\n            v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\r\n            v6 = t;\r\n            // stage 1\r\n            p[(0 * 8) + col] = v0 + v7;\r\n            p[(7 * 8) + col] = v0 - v7;\r\n            p[(1 * 8) + col] = v1 + v6;\r\n            p[(6 * 8) + col] = v1 - v6;\r\n            p[(2 * 8) + col] = v2 + v5;\r\n            p[(5 * 8) + col] = v2 - v5;\r\n            p[(3 * 8) + col] = v3 + v4;\r\n            p[(4 * 8) + col] = v3 - v4;\r\n        }\r\n        // convert to 8-bit integers\r\n        for (i = 0; i < 64; ++i) {\r\n            const sample = 128 + ((p[i] + 8) >> 4);\r\n            if (sample < 0) {\r\n                dataOut[i] = 0;\r\n            }\r\n            else if (sample > 0XFF) {\r\n                dataOut[i] = 0xFF;\r\n            }\r\n            else {\r\n                dataOut[i] = sample;\r\n            }\r\n        }\r\n    }\r\n    for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\r\n        const scanLine = blockRow << 3;\r\n        for (let i = 0; i < 8; i++) {\r\n            lines.push(new Uint8Array(samplesPerLine));\r\n        }\r\n        for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {\r\n            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\r\n            let offset = 0;\r\n            const sample = blockCol << 3;\r\n            for (let j = 0; j < 8; j++) {\r\n                const line = lines[scanLine + j];\r\n                for (let i = 0; i < 8; i++) {\r\n                    line[sample + i] = r[offset++];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return lines;\r\n}\r\nclass JpegStreamReader {\r\n    constructor() {\r\n        this.jfif = null;\r\n        this.adobe = null;\r\n        this.quantizationTables = [];\r\n        this.huffmanTablesAC = [];\r\n        this.huffmanTablesDC = [];\r\n        this.frames = [];\r\n    }\r\n    resetFrames() {\r\n        this.frames = [];\r\n    }\r\n    parse(data) {\r\n        let offset = 0;\r\n        // const { length } = data;\r\n        function readUint16() {\r\n            const value = (data[offset] << 8) | data[offset + 1];\r\n            offset += 2;\r\n            return value;\r\n        }\r\n        function readDataBlock() {\r\n            const length = readUint16();\r\n            const array = data.subarray(offset, offset + length - 2);\r\n            offset += array.length;\r\n            return array;\r\n        }\r\n        function prepareComponents(frame) {\r\n            let maxH = 0;\r\n            let maxV = 0;\r\n            let component;\r\n            let componentId;\r\n            for (componentId in frame.components) {\r\n                if (frame.components.hasOwnProperty(componentId)) {\r\n                    component = frame.components[componentId];\r\n                    if (maxH < component.h) {\r\n                        maxH = component.h;\r\n                    }\r\n                    if (maxV < component.v) {\r\n                        maxV = component.v;\r\n                    }\r\n                }\r\n            }\r\n            const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\r\n            const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\r\n            for (componentId in frame.components) {\r\n                if (frame.components.hasOwnProperty(componentId)) {\r\n                    component = frame.components[componentId];\r\n                    const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\r\n                    const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\r\n                    const blocksPerLineForMcu = mcusPerLine * component.h;\r\n                    const blocksPerColumnForMcu = mcusPerColumn * component.v;\r\n                    const blocks = [];\r\n                    for (let i = 0; i < blocksPerColumnForMcu; i++) {\r\n                        const row = [];\r\n                        for (let j = 0; j < blocksPerLineForMcu; j++) {\r\n                            row.push(new Int32Array(64));\r\n                        }\r\n                        blocks.push(row);\r\n                    }\r\n                    component.blocksPerLine = blocksPerLine;\r\n                    component.blocksPerColumn = blocksPerColumn;\r\n                    component.blocks = blocks;\r\n                }\r\n            }\r\n            frame.maxH = maxH;\r\n            frame.maxV = maxV;\r\n            frame.mcusPerLine = mcusPerLine;\r\n            frame.mcusPerColumn = mcusPerColumn;\r\n        }\r\n        let fileMarker = readUint16();\r\n        if (fileMarker !== 0xFFD8) { // SOI (Start of Image)\r\n            throw new Error('SOI not found');\r\n        }\r\n        fileMarker = readUint16();\r\n        while (fileMarker !== 0xFFD9) { // EOI (End of image)\r\n            switch (fileMarker) {\r\n                case 0xFF00: break;\r\n                case 0xFFE0: // APP0 (Application Specific)\r\n                case 0xFFE1: // APP1\r\n                case 0xFFE2: // APP2\r\n                case 0xFFE3: // APP3\r\n                case 0xFFE4: // APP4\r\n                case 0xFFE5: // APP5\r\n                case 0xFFE6: // APP6\r\n                case 0xFFE7: // APP7\r\n                case 0xFFE8: // APP8\r\n                case 0xFFE9: // APP9\r\n                case 0xFFEA: // APP10\r\n                case 0xFFEB: // APP11\r\n                case 0xFFEC: // APP12\r\n                case 0xFFED: // APP13\r\n                case 0xFFEE: // APP14\r\n                case 0xFFEF: // APP15\r\n                case 0xFFFE: { // COM (Comment)\r\n                    const appData = readDataBlock();\r\n                    if (fileMarker === 0xFFE0) {\r\n                        if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49\r\n                            && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\r\n                            this.jfif = {\r\n                                version: { major: appData[5], minor: appData[6] },\r\n                                densityUnits: appData[7],\r\n                                xDensity: (appData[8] << 8) | appData[9],\r\n                                yDensity: (appData[10] << 8) | appData[11],\r\n                                thumbWidth: appData[12],\r\n                                thumbHeight: appData[13],\r\n                                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),\r\n                            };\r\n                        }\r\n                    }\r\n                    // TODO APP1 - Exif\r\n                    if (fileMarker === 0xFFEE) {\r\n                        if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F\r\n                            && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\r\n                            this.adobe = {\r\n                                version: appData[6],\r\n                                flags0: (appData[7] << 8) | appData[8],\r\n                                flags1: (appData[9] << 8) | appData[10],\r\n                                transformCode: appData[11],\r\n                            };\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case 0xFFDB: { // DQT (Define Quantization Tables)\r\n                    const quantizationTablesLength = readUint16();\r\n                    const quantizationTablesEnd = quantizationTablesLength + offset - 2;\r\n                    while (offset < quantizationTablesEnd) {\r\n                        const quantizationTableSpec = data[offset++];\r\n                        const tableData = new Int32Array(64);\r\n                        if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\r\n                            for (let j = 0; j < 64; j++) {\r\n                                const z = dctZigZag[j];\r\n                                tableData[z] = data[offset++];\r\n                            }\r\n                        }\r\n                        else if ((quantizationTableSpec >> 4) === 1) { // 16 bit\r\n                            for (let j = 0; j < 64; j++) {\r\n                                const z = dctZigZag[j];\r\n                                tableData[z] = readUint16();\r\n                            }\r\n                        }\r\n                        else {\r\n                            throw new Error('DQT: invalid table spec');\r\n                        }\r\n                        this.quantizationTables[quantizationTableSpec & 15] = tableData;\r\n                    }\r\n                    break;\r\n                }\r\n                case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\r\n                case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\r\n                case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)\r\n                    readUint16(); // skip data length\r\n                    const frame = {\r\n                        extended: (fileMarker === 0xFFC1),\r\n                        progressive: (fileMarker === 0xFFC2),\r\n                        precision: data[offset++],\r\n                        scanLines: readUint16(),\r\n                        samplesPerLine: readUint16(),\r\n                        components: {},\r\n                        /** @type {any[]} */\r\n                        componentsOrder: [],\r\n                    };\r\n                    const componentsCount = data[offset++];\r\n                    let componentId;\r\n                    // let maxH = 0;\r\n                    // let maxV = 0;\r\n                    for (let i = 0; i < componentsCount; i++) {\r\n                        componentId = data[offset];\r\n                        const h = data[offset + 1] >> 4;\r\n                        const v = data[offset + 1] & 15;\r\n                        const qId = data[offset + 2];\r\n                        frame.componentsOrder.push(componentId);\r\n                        frame.components[componentId] = {\r\n                            h,\r\n                            v,\r\n                            quantizationIdx: qId,\r\n                        };\r\n                        offset += 3;\r\n                    }\r\n                    prepareComponents(frame);\r\n                    this.frames.push(frame);\r\n                    break;\r\n                }\r\n                case 0xFFC4: { // DHT (Define Huffman Tables)\r\n                    const huffmanLength = readUint16();\r\n                    for (let i = 2; i < huffmanLength;) {\r\n                        const huffmanTableSpec = data[offset++];\r\n                        const codeLengths = new Uint8Array(16);\r\n                        let codeLengthSum = 0;\r\n                        for (let j = 0; j < 16; j++, offset++) {\r\n                            codeLengths[j] = data[offset];\r\n                            codeLengthSum += codeLengths[j];\r\n                        }\r\n                        const huffmanValues = new Uint8Array(codeLengthSum);\r\n                        for (let j = 0; j < codeLengthSum; j++, offset++) {\r\n                            huffmanValues[j] = data[offset];\r\n                        }\r\n                        i += 17 + codeLengthSum;\r\n                        if ((huffmanTableSpec >> 4) === 0) {\r\n                            this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\r\n                        }\r\n                        else {\r\n                            this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case 0xFFDD: // DRI (Define Restart Interval)\r\n                    readUint16(); // skip data length\r\n                    this.resetInterval = readUint16();\r\n                    break;\r\n                case 0xFFDA: { // SOS (Start of Scan)\r\n                    readUint16(); // skip length\r\n                    const selectorsCount = data[offset++];\r\n                    const components = [];\r\n                    const frame = this.frames[0];\r\n                    for (let i = 0; i < selectorsCount; i++) {\r\n                        const component = frame.components[data[offset++]];\r\n                        const tableSpec = data[offset++];\r\n                        component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];\r\n                        component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];\r\n                        components.push(component);\r\n                    }\r\n                    const spectralStart = data[offset++];\r\n                    const spectralEnd = data[offset++];\r\n                    const successiveApproximation = data[offset++];\r\n                    const processed = decodeScan(data, offset, frame, components, this.resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);\r\n                    offset += processed;\r\n                    break;\r\n                }\r\n                case 0xFFFF: // Fill bytes\r\n                    if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\r\n                        offset--;\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (data[offset - 3] === 0xFF\r\n                        && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\r\n                        // could be incorrect encoding -- last 0xFF byte of the previous\r\n                        // block was eaten by the encoder\r\n                        offset -= 3;\r\n                        break;\r\n                    }\r\n                    throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);\r\n            }\r\n            fileMarker = readUint16();\r\n        }\r\n    }\r\n    getResult() {\r\n        const { frames } = this;\r\n        if (this.frames.length === 0) {\r\n            throw new Error('no frames were decoded');\r\n        }\r\n        else if (this.frames.length > 1) {\r\n            console.warn('more than one frame is not supported');\r\n        }\r\n        // set each frame's components quantization table\r\n        for (let i = 0; i < this.frames.length; i++) {\r\n            const cp = this.frames[i].components;\r\n            for (const j of Object.keys(cp)) {\r\n                cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];\r\n                delete cp[j].quantizationIdx;\r\n            }\r\n        }\r\n        const frame = frames[0];\r\n        const { components, componentsOrder } = frame;\r\n        const outComponents = [];\r\n        const width = frame.samplesPerLine;\r\n        const height = frame.scanLines;\r\n        for (let i = 0; i < componentsOrder.length; i++) {\r\n            const component = components[componentsOrder[i]];\r\n            outComponents.push({\r\n                lines: buildComponentData(frame, component),\r\n                scaleX: component.h / frame.maxH,\r\n                scaleY: component.v / frame.maxV,\r\n            });\r\n        }\r\n        const out = new Uint8Array(width * height * outComponents.length);\r\n        let oi = 0;\r\n        for (let y = 0; y < height; ++y) {\r\n            for (let x = 0; x < width; ++x) {\r\n                for (let i = 0; i < outComponents.length; ++i) {\r\n                    const component = outComponents[i];\r\n                    out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];\r\n                    ++oi;\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n}\r\nexport default class JpegDecoder extends BaseDecoder {\r\n    constructor(parameters) {\r\n        super(parameters);\r\n        this.reader = new JpegStreamReader();\r\n        if (parameters.JPEGTables) {\r\n            this.reader.parse(parameters.JPEGTables);\r\n        }\r\n    }\r\n    decodeBlock(buffer) {\r\n        this.reader.resetFrames();\r\n        this.reader.parse(new Uint8Array(buffer));\r\n        return this.reader.getResult().buffer;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["n", "component", "k", "mcu"]
}
